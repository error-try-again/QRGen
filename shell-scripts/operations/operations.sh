#!/bin/bash

# --- User Actions --- #

# Dumps logs of all containers orchestrated by the Docker Compose file.
dump_logs() {
  test_docker_env
  produce_docker_logs >"$PROJECT_LOGS_DIR/service.log" && {
    echo "Docker logs dumped to $PROJECT_LOGS_DIR/service.log"
    cat "$PROJECT_LOGS_DIR/service.log"
  }
}

# Cleans current Docker Compose setup, arranges directories, and reinitiates Docker services.
reload_project() {
  echo "Reloading the project..."
  test_docker_env
  setup_project_directories
  bring_down_docker_compose
  generate_server_files
  configure_nginx
  build_and_run_docker
  dump_logs
}

# Shuts down any running Docker containers associated with the project and deletes the entire project directory.
cleanup() {
  test_docker_env
  kill_cert_watcher
  echo "Cleaning up..."

  bring_down_docker_compose

  declare -A directories=(
    ["Project"]=$PROJECT_ROOT_DIR
    ["Frontend"]=$FRONTEND_DIR
    ["Backend"]=$BACKEND_DIR
  )

  local dir_name
  local dir_path

  for dir_name in "${!directories[@]}"; do
    dir_path="${directories[$dir_name]}"
    if [[ -d "$dir_path" ]]; then
      rm -rf "$dir_path" && cd ..
      echo "$dir_name directory $dir_path deleted."
    fi
  done

  echo "Cleanup complete."
}

update_project() {
  git stash
  git pull
}

purge_builds() {
  test_docker_env
  kill_cert_watcher
  local containers
  containers=$(docker ps -a -q)
  echo "Stopping all containers..."
  if [ -n "$containers" ]; then
    docker stop $containers
  else
    echo "No containers to stop."
  fi
  echo "Purging Docker builds..."
  docker system prune -a
}

quit() {
  echo "Exiting..."
  exit 0
}

kill_cert_watcher() {
  local pid_file="./cert-watcher.pid"
  if [[ -f "$pid_file" ]]; then
    local pid
    pid=$(cat "$pid_file")

    # Check if the PID is actually running
    if ps -p "$pid" >/dev/null 2>&1; then
      echo "Stopping cert watcher with PID $pid."
      kill "$pid" && echo "Cert watcher stopped successfully." || echo "Failed to stop cert watcher."

      # Optionally remove the PID file after killing the process
      rm -f "$pid_file"
    else
      echo "No cert watcher process found running with PID $pid."
    fi
  else
    echo "PID file does not exist. Cert watcher may not be running."
  fi
}

# ---- Build and Run Docker ---- #

build_and_run_docker() {

  # Handle Let's Encrypt configuration
  if [[ "$USE_LETS_ENCRYPT" == "yes" ]]; then

    # Generate self-signed certificates if they don't exist
    generate_self_signed_certificates

    # Start cert watcher here to ensure that changes to the self-signed certs are
    # picked up by ifnotify if they are regenerated by certbot after this
    initialize_cert_watcher || {
      echo "Failed to initialize cert watcher"
      exit 1
    }

  fi

  echo "Building and running Docker setup..."

  # Build Docker image
  docker compose build || {
    echo "Failed to build Docker image using Docker Compose"
    exit 1
  }

  docker compose up -d || {
    echo "Failed to run Docker Compose"
    exit 1
  }

  docker compose ps
  dump_logs
}
